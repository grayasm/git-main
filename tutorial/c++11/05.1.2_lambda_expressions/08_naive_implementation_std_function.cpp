/* Header     : <functional>
   Signature  : template<class> class function;
                template<class R, class... Args> class function<R(Args...)>;

   Description: class std::function is a general-purpose polymorphic function
                wrapper. It can store, copy and invoke any callable target
                function, lambda expression, bind expression or another
                function object, as well as pointer to function and pointer
                to data members.

This is my own study on std::function

   Few things were looking really strange, like these:

   a) std::function<bool(double, double)> f = [](double x, double y) -> bool
                                              { return true; }

   The only naive implementation and tips on how it works I could find here:
   https://shaharmike.com/cpp/naive-std-function/

   Find below my own simplified AT MAXIM version.
 */

#include <iostream>


template<typename R, typename... A>
class invoke_base
{
public:
	virtual ~invoke_base() = default;
	virtual R invoke(A...) = 0;
};


template<typename R, typename F, typename... A>
class invoke_derived : public invoke_base<R, A...>
{
public:
	invoke_derived(F& pfn) : m_pfn(pfn) { }
	~invoke_derived() override = default;
	R invoke(A... a) override { return m_pfn(a...); }
private:
	F& m_pfn;
};


template<typename T>
struct function;


template<typename R, typename... A>
struct function<R (A...)>
{
	R operator()(A... a)
	{
		return m_pfn->invoke(a...);
	}

	template<typename F>
	function(F pfn)
	{
		m_pfn = new invoke_derived<R, F, A...>(pfn);
	}

	~function() { delete m_pfn; }

	invoke_base<R, A...>* m_pfn;
};

int F0(const char* txt, unsigned int len)
{
	std::cout << __FUNCTION__ << "(" << txt << ", " << len << ")\n";
	return len;
}

int main()
{
	function<int(const char*, unsigned int)> f0 = F0;
	f0("apeleaza", 210224);

	function<bool(const char*, unsigned int)> f1 =
		                      [=](const char* txt, unsigned int len) -> int
		                      {
			                      std::cout << __FUNCTION__ << "(" << txt
			                                << ", " << len << ")\n";
			                      return len;
		                      };
	f1("apeleaza", 210228);

	return 0;
}
/*
F0(apeleaza, 210224)
operator()(apeleaza, 210228)
*/


/*
  Two alternatives were possible
  (a) function<bool,int,int>  f = [](int x, int y) { return x == y; };
  (b) function<bool(int,int)> f = [](int x, int y) { return x == y; };

  and the (b) is the preference of the majority. To achieve it we need to
  have (1) an empty declaration of function (line 49) and a partial template
  specialization (line 53) with only 2 template types R and ...A

  This in turn moves the type <F> of the pointer to function to constructor
  definition (line 60).

  Now, <F> cannot appear in the function body, so it must be wrapped
  by invoke_derived and hidden by having only a pointer to invoke_base (line 68)
  in the struct body.

  This moves the call to user function pointer into invoke_derived (line 42).

  In line 44 F& must be an address because lambda (generated by the compiler)
  has a deleted default constructor and does not compile as F

  This samples is valid (builds & runs) and is short so it can be readable.
 */
