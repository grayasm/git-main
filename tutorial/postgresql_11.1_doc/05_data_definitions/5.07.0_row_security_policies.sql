/*  Chapter 5. Data Definition
    5.7. Row Security Policies

    # for this sample connect over localhost as user=postgres
    psql -h 127.0.0.1 -d mytestdb -U postgres
    \i 5.07.0_row_security_policies.sql
    \?
    \qecho '\033[2J'
*/


/*
    Row security policies is a PostgreSQL extension via CREATE POLICY, that
    restricts which rows can be returned,inserted,updated or deleted by normal
    queries on a per user basis. It is also known as RLS or Row-Level-Security.

    CREATE POLICY name ON table_name
           [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]
           [ TO  { role_name | PUBLIC | CURRENT_USER | SESSION_USER } [,...] ]
           [ USING ( using_expression ) ]
           [ WITH CHECK ( check_expression ) ]

    ALTER POLICY name ON table_name RENAME TO new_name
    ALTER POLICY name ON table_name
          [ TO { role_name | PUBLIC | CURRENT_USER | SESSION_USER } [,...] ]
          [ USING ( using_expression ) ]
          [ WITH CHECK ( check_expression ) ]

    DROP POLICY [ IF EXISTS ] name ON table_name

    By default RLS is off. Turn it on with:

    ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;
    ALTER TABLE table_name FORCE  ROW LEVEL SECURITY;

    For RLS to be effective, other users must be granted access to the table.
    GRANT command has 2 versions:
    1. grants privileges on a database object like:
       table,column,view,sequence,database,foreign-data wrapper,foreign server,
       function,procedural language,schema or tablespace and,
    2. grants membership in a role.
    See previous file about privileges.
*/


/*  Starting with this example:
    https://info.crunchydata.com/blog/a-postgresql-row-level-security-primer-creating-large-policies
    A PostgreSQL Row Level Security Primer + Creating Large Policies
*/


/*** Run as user=postgres, so it can set back and forth to different users. */
SET ROLE postgres;
SELECT CURRENT_USER;
/*
 current_user
--------------
 postgres
(1 row)
*/

DROP TABLE IF EXISTS public.accounts CASCADE;
DROP ROLE IF EXISTS jkatz;

CREATE TABLE public.accounts (
       id           INT  GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       username     TEXT UNIQUE NOT NULL,
       full_name    TEXT NOT NULL,
       created_at   timestamp with time zone NOT NULL);

INSERT INTO public.accounts (username, full_name, created_at) VALUES
       ('jkatz',    'Jonathan Katz',    CURRENT_TIMESTAMP), /* testing user */
       ('mmorgan',  'Melissa Morgan',   CURRENT_TIMESTAMP),
       ('tcoleman', 'Tristan Coleman',  CURRENT_TIMESTAMP),
       ('snelson',  'Stacie Nelson',    CURRENT_TIMESTAMP),
       ('mflores',  'Michael Flores',   CURRENT_TIMESTAMP),
       ('mandrews', 'Michael Andrews',  CURRENT_TIMESTAMP),
       ('nramirez', 'Nicole Ramirez',   CURRENT_TIMESTAMP),
       ('mscott',   'Mark Scott',       CURRENT_TIMESTAMP),
       ('kmooney',  'Kimberly Mooney',  CURRENT_TIMESTAMP),
       ('mbrown',   'Michelle Brown',   CURRENT_TIMESTAMP),
       ('nramirez1', 'Nancy Ramirez',   CURRENT_TIMESTAMP),
       ('mgray',    'Michael Gray',     CURRENT_TIMESTAMP),
       ('rjimenez', 'Richard Jimenez',  CURRENT_TIMESTAMP),
       ('vwhite',   'Victoria White',   CURRENT_TIMESTAMP),
       ('jsmith',   'Jennifer Smith',   CURRENT_TIMESTAMP),
       ('mcarter',  'Mark Carter',      CURRENT_TIMESTAMP),
       ('mhenry',   'Monique Henry',    CURRENT_TIMESTAMP),
       ('rdoyle',   'Robert Doyle',     CURRENT_TIMESTAMP),
       ('nwilliams', 'Nathaniel Williams', CURRENT_TIMESTAMP),
       ('klewis',   'Kristen Lewis',    CURRENT_TIMESTAMP),
       ('kwilson',  'Kevin Wilson',     CURRENT_TIMESTAMP);


CREATE ROLE jkatz WITH PASSWORD 'NotVeryImportant';
SET ROLE jkatz;
SELECT * FROM public.accounts;
-- ERROR:  permission denied for table accounts


/*** GRANT SELECT access to table for user jkatz. */
SET ROLE postgres;
GRANT SELECT ON public.accounts TO jkatz;
SET ROLE jkatz;

SELECT * FROM public.accounts;
/*
 id | username  |     full_name      |          created_at
----+-----------+--------------------+-------------------------------
  1 | jkatz     | Jonathan Katz      | 2019-02-17 09:20:39.123533+00
  2 | mmorgan   | Melissa Morgan     | 2019-02-17 09:20:39.123533+00
  3 | tcoleman  | Tristan Coleman    | 2019-02-17 09:20:39.123533+00
  4 | snelson   | Stacie Nelson      | 2019-02-17 09:20:39.123533+00
...
*/


/*** Set up the Row Level Security for accounts table. */
SET ROLE postgres;
CREATE POLICY accounts_policy ON public.accounts USING (username = CURRENT_USER);
ALTER TABLE public.accounts ENABLE ROW LEVEL SECURITY;

SET ROLE jkatz;
SELECT * FROM public.accounts;
/*
 id | username |   full_name   |          created_at
----+----------+---------------+-------------------------------
  1 | jkatz    | Jonathan Katz | 2019-02-17 09:36:37.627164+00
(1 row)
*/

UPDATE public.accounts SET full_name = 'Jonathan S. Katz' WHERE username = 'jkatz';
-- ERROR:  permission denied for table accounts


/*** GRANT UPDATE acces to table's full_name field for user jkatz. */
SET ROLE postgres;
GRANT UPDATE (full_name) ON public.accounts TO jkatz;

SET ROLE jkatz;
UPDATE public.accounts SET full_name = 'Jonathan S. Katz' WHERE username = 'jkatz';
-- UPDATE 1

UPDATE public.accounts SET created_at = CURRENT_TIMESTAMP WHERE username = 'jkatz';
-- ERROR:  permission denied for table accounts



/*** Create a different policy for accounts table. */
SET ROLE postgres;
DROP POLICY IF EXISTS accounts_policy ON public.accounts;
CREATE POLICY accounts_policy
       ON public.accounts
       USING (username = CURRENT_USER)
       WITH CHECK (
            full_name NOT IN (
                'Sean Thomas',
                'Mr. Corey Frank',
                'Brenda Thomas',
                'Robert Johnson', /* <-- */
                'Kelly Maddox',
                'Erin Klein',
                'Justin Carr',
                'Michelle Jacobs',
                'Carla Wallace',
                'Jason Moore',
                'Mark Cole',
                'Kathryn Jackson',
                'Traci Garcia',
                'Wesley Byrd',
                'Elizabeth Dunn',
                'Timothy Jones',
                'Michael Farrell',
                'Amber Combs',
                'Victoria Martinez',
                'Austin Roberts',
                'Valerie Love'));

SET ROLE jkatz;
UPDATE public.accounts SET full_name = 'Robert Johnson' WHERE username = 'jkatz';
-- ERROR:  new row violates row-level security policy for table "accounts" (OK)


/*** Create a similar policy for accounts table. */
SET ROLE postgres;
DROP POLICY IF EXISTS accounts_policy ON public.accounts;
CREATE OR REPLACE FUNCTION accounts_is_excluded_full_name(text)
       RETURNS boolean
       AS
       $$
            /* returns true if full-name is in the exclusion list */
            SELECT $1 = ANY ( ARRAY [
                'Sean Thomas',
                'Mr. Corey Frank',
                'Brenda Thomas',
                'Robert Johnson', /* <-- */
                'Kelly Maddox',
                'Erin Klein',
                'Justin Carr',
                'Michelle Jacobs',
                'Carla Wallace',
                'Jason Moore',
                'Mark Cole',
                'Kathryn Jackson',
                'Traci Garcia',
                'Wesley Byrd',
                'Elizabeth Dunn',
                'Timothy Jones',
                'Michael Farrell',
                'Amber Combs',
                'Victoria Martinez',
                'Austin Roberts',
                'Valerie Love'
            ]);
       $$ LANGUAGE SQL IMMUTABLE;

BEGIN;
    DROP POLICY IF EXISTS accounts_policy ON public.accounts;
    CREATE POLICY accounts_policy
        ON public.accounts
        USING (username = CURRENT_USER)
        WITH CHECK (NOT accounts_is_excluded_full_name (full_name));
COMMIT;

SET ROLE jkatz;
UPDATE public.accounts SET full_name = 'Robert Johnson' WHERE username = 'jkatz';
-- ERROR:  new row violates row-level security policy for table "accounts" (OK)

/*** Clean up */
SET ROLE postgres;
DROP FUNCTION IF EXISTS accounts_is_excluded_full_name CASCADE;
DROP POLICY IF EXISTS accounts_policy ON public.accounts;
DROP TABLE IF EXISTS public.accounts CASCADE;
DROP ROLE IF EXISTS jkatz;


/*** Follow the example from PostgreSQL 11.1 Documentation, cap.5.7 */
DROP POLICY IF EXISTS admin_all ON passwd;
DROP POLICY IF EXISTS all_view  ON passwd;
DROP POLICY IF EXISTS user_mod  ON passwd;
DROP POLICY IF EXISTS admin_local_only ON passwd;
DROP TABLE IF EXISTS passwd CASCADE;
DROP ROLE IF EXISTS admin, bob, alice;

CREATE TABLE passwd (
       user_name        TEXT UNIQUE NOT NULL,
       pwhash           TEXT,
       uid              INT PRIMARY KEY,
       gid              INT NOT NULL,
       real_name        TEXT NOT NULL,
       home_phone       TEXT,
       extra_info       TEXT,
       home_dir         TEXT NOT NULL,
       shell            TEXT NOT NULL);

CREATE ROLE admin;      -- Administrator
CREATE ROLE bob;        -- Normal user
CREATE ROLE alice;      -- Normal user

INSERT INTO passwd VALUES
    ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root',      '/bin/dash'),
    ('bob',  'xxx',1,1,'Bob',  '123-456-7890',null,'/home/bob',  '/bin/zsh'),
    ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

CREATE POLICY admin_all ON passwd TO admin USING(true) WITH CHECK(true);
CREATE POLICY all_view  ON passwd FOR SELECT USING(true);
CREATE POLICY user_mod  ON passwd /* limit which shell a normal user can set */
    FOR UPDATE
    USING(user_name = CURRENT_USER)
    WITH CHECK (
         user_name = CURRENT_USER AND
         shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
    );

GRANT SELECT,INSERT,UPDATE,DELETE ON passwd TO admin;
GRANT SELECT(user_name,/*no hash*/uid,gid,real_name,home_phone,extra_info,
             home_dir,shell)
             ON passwd TO public;
GRANT UPDATE(pwhash,real_name,home_phone,extra_info,shell)
             ON passwd TO public;

/*** Test and ensure that the system is behaving as expected. */
/*** admin can view all rows and fields */
SET ROLE admin;
TABLE passwd;
/*
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info |  home_dir   |   shell   
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)
*/

/*** Test what Alice can do. */
SET ROLE alice;
TABLE passwd;
-- ERROR:  permission denied for table passwd

SELECT user_name,real_name,home_phone,extra_info,home_dir,shell FROM passwd;
/*
 user_name | real_name |  home_phone  | extra_info |  home_dir   |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)
*/

UPDATE passwd SET user_name = 'joe';
-- ERROR:  permission denied for table passwd
/* Alice is allowed to change her own real_name, but no others. */

UPDATE passwd SET real_name = 'Alice Doe';                          -- UPDATE 1
UPDATE passwd SET real_name = 'John Doe' WHERE user_name = 'admin'; -- UPDATE 0
UPDATE passwd SET shell = '/bin/xx';
-- ERROR:  new row violates row-level security policy for table "passwd"

DELETE FROM passwd;
-- ERROR:  permission denied for table passwd

INSERT INTO passwd(user_name) VALUES ('xxx');
-- ERROR:  permission denied for table passwd

/* Alice can change her own password. RLS prevents updating other's rows */
UPDATE passwd SET pwhash = 'abc';  -- UPDATE 1

/*** Create a restrictive policy (all before were permissive) such that
     an administrator connecting over a network will not see any records. */
SET ROLE postgres;
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
       USING (pg_catalog.inet_client_addr() IS NULL);

SET ROLE admin;
TABLE passwd;
/*
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell 
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)
*/

UPDATE passwd SET pwhash = NULL; -- UPDATE 0


/*** Clean up*/
SET ROLE postgres;
DROP POLICY IF EXISTS admin_all ON passwd;
DROP POLICY IF EXISTS all_view  ON passwd;
DROP POLICY IF EXISTS user_mod  ON passwd;
DROP POLICY IF EXISTS admin_local_only ON passwd;
DROP TABLE IF EXISTS passwd CASCADE;
DROP ROLE IF EXISTS admin, bob, alice;
