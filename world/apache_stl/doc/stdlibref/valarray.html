<!--
    Licensed to the Apache Software  Foundation (ASF) under one or more
    contributor  license agreements.  See  the NOTICE  file distributed
    with  this  work  for  additional information  regarding  copyright
    ownership.   The ASF  licenses this  file to  you under  the Apache
    License, Version  2.0 (the  License); you may  not use  this file
    except in  compliance with the License.   You may obtain  a copy of
    the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the  License is distributed on an  "AS IS" BASIS,
    WITHOUT  WARRANTIES OR CONDITIONS  OF ANY  KIND, either  express or
    implied.   See  the License  for  the  specific language  governing
    permissions and limitations under the License.

    Copyright 1999-2007 Rogue Wave Software, Inc.
-->

<HTML>
<HEAD>
<TITLE>valarray</TITLE>
<LINK REL=StyleSheet HREF="../rw.css" TYPE="text/css" TITLE="Apache stdcxx Stylesheet"></HEAD>
<BODY BGCOLOR=#FFFFFF>
<A HREF="valarray-h.html"><IMG SRC="images/bprev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=O></A><A HREF="noframes.html"><IMG SRC="images/btop.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.html"><IMG SRC="images/btoc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=O></A><A HREF="tindex.html"><IMG SRC="images/bindex.gif" WIDTH=56 HEIGHT=21 ALT="Index page" BORDER=O></A><A HREF="vector-h.html"><IMG SRC="images/bnext.gif" WIDTH=25 HEIGHT=21 ALT="Next file" BORDER=O></A><DIV CLASS="DOCUMENTNAME"><B>Apache C++ Standard Library Reference Guide</B></DIV>
<H2>valarray</H2>
<P><B>Library:</B>&nbsp;&nbsp;<A HREF="2-10.html">Numerics</A></P>

<PRE><HR><B><I>Does not inherit</I></B><HR></PRE>

<UL>
<LI><A HREF="#sec1">Local Index</A></LI>
<LI><A HREF="#sec2">Summary</A></LI>
<LI><A HREF="#sec3">Synopsis</A></LI>
<LI><A HREF="#sec4">Description</A></LI>
<LI><A HREF="#sec5">Interface</A></LI>
<LI><A HREF="#sec6">Constructors</A></LI>
<LI><A HREF="#sec7">Destructor</A></LI>
<LI><A HREF="#sec8">Assignment Operators</A></LI>
<LI><A HREF="#sec9">Element Access Operators</A></LI>
<LI><A HREF="#sec10">Subset Operators</A></LI>
<LI><A HREF="#sec11">Unary Operators</A></LI>
<LI><A HREF="#sec12">Computed Assignment Operators</A></LI>
<LI><A HREF="#sec13">Member Functions</A></LI>
<LI><A HREF="#sec14">Nonmember Binary Operators</A></LI>
<LI><A HREF="#sec15">Nonmember Logical Operators</A></LI>
<LI><A HREF="#sec16">Nonmember Transcen-dental Functions</A></LI>
<LI><A HREF="#sec17">Example</A></LI>
<LI><A HREF="#sec18">See Also</A></LI>
<LI><A HREF="#sec19">Standards Conformance</A></LI>
</UL>
<A NAME="sec1"><H3>Local Index</H3></A>
<H4>Members</H4>
<UL><TABLE CELLPADDING=3>
<TR><TD VALIGN=top>
<A HREF="#idx1292">apply()</A><BR>
<A HREF="#idx1291">cshift()</A><BR>
<A HREF="#idx1289">max()</A><BR>
<A HREF="#idx1288">min()</A><BR>
<A HREF="#idx1283">operator!()</A><BR>
<A HREF="#idx1284">operator%=()</A><BR>
<A HREF="#idx1284">operator&amp;=()</A><BR>
</TD>
<TD VALIGN=top><A HREF="#idx1284">operator&gt;&gt;=()</A><BR>
<A HREF="#idx1284">operator&lt;&lt;=()</A><BR>
<A HREF="#idx1284">operator*=()</A><BR>
<A HREF="#idx1280">operator+()</A><BR>
<A HREF="#idx1284">operator+=()</A><BR>
<A HREF="#idx1281">operator-()</A><BR>
<A HREF="#idx1284">operator-=()</A><BR>
</TD>
<TD VALIGN=top><A HREF="#idx1284">operator/=()</A><BR>
<A HREF="#idx1264">operator=()</A><BR>
<A HREF="#idx1270">operator[]()</A><BR>
<A HREF="#idx1284">operator^=()</A><BR>
<A HREF="#idx1285">operator^=()</A><BR>
<A HREF="#idx1284">operator|=()</A><BR>
<A HREF="#idx1282">operator~()</A><BR>
</TD>
<TD VALIGN=top><A HREF="#idx1294">resize()</A><BR>
<A HREF="#idx1290">shift()</A><BR>
<A HREF="#idx1286">size()</A><BR>
<A HREF="#idx1287">sum()</A><BR>
<A HREF="#idx1254">valarray()</A><BR>
<A HREF="#idx1263">~valarray()</A><BR>
</TD></TR>
</TABLE></UL>
<H4>Non-Members</H4>
<UL><TABLE CELLPADDING=3>
<TR><TD VALIGN=top>
<A HREF="#idx1301">abs()</A><BR>
<A HREF="#idx1301">acos()</A><BR>
<A HREF="#idx1301">asin()</A><BR>
<A HREF="#idx1301">atan()</A><BR>
<A HREF="#idx1302">atan2()</A><BR>
<A HREF="#idx1301">cos()</A><BR>
<A HREF="#idx1301">cosh()</A><BR>
<A HREF="#idx1301">exp()</A><BR>
<A HREF="#idx1301">log()</A><BR>
</TD>
<TD VALIGN=top><A HREF="#idx1301">log10()</A><BR>
<A HREF="#idx1298">operator!=()</A><BR>
<A HREF="#idx1295">operator%()</A><BR>
<A HREF="#idx1298">operator&amp;&amp;()</A><BR>
<A HREF="#idx1295">operator&amp;()</A><BR>
<A HREF="#idx1295">operator&gt;&gt;()</A><BR>
<A HREF="#idx1298">operator&gt;()</A><BR>
<A HREF="#idx1298">operator&gt;=()</A><BR>
<A HREF="#idx1295">operator&lt;&lt;()</A><BR>
</TD>
<TD VALIGN=top><A HREF="#idx1298">operator&lt;()</A><BR>
<A HREF="#idx1298">operator&lt;=()</A><BR>
<A HREF="#idx1295">operator*()</A><BR>
<A HREF="#idx1295">operator+()</A><BR>
<A HREF="#idx1295">operator-()</A><BR>
<A HREF="#idx1295">operator/()</A><BR>
<A HREF="#idx1298">operator==()</A><BR>
<A HREF="#idx1296">operator^()</A><BR>
<A HREF="#idx1295">operator^()</A><BR>
</TD>
<TD VALIGN=top><A HREF="#idx1297">operator^()</A><BR>
<A HREF="#idx1295">operator|()</A><BR>
<A HREF="#idx1298">operator||()</A><BR>
<A HREF="#idx1302">pow()</A><BR>
<A HREF="#idx1301">sin()</A><BR>
<A HREF="#idx1301">sinh()</A><BR>
<A HREF="#idx1301">sqrt()</A><BR>
<A HREF="#idx1301">tan()</A><BR>
<A HREF="#idx1301">tanh()</A><BR>
</TD></TR>
</TABLE></UL>

<A NAME="sec2"><H3>Summary</H3></A>
<P>An optimized array class for numeric operations</P>
<A NAME="sec3"><H3>Synopsis</H3></A>

<PRE>#include &lt;valarray&gt;

namespace std {
  template &lt;class T &gt;
  class valarray;
}
</PRE>
<A NAME="sec4"><H3>Description</H3></A>
<P>Class <B><I>valarray</I></B> and its associated classes <B><I><A HREF="slice-array.html">slice_array</A></I></B>, <B><I><A HREF="gslice-array.html">gslice_array</A></I></B>, <B><I><A HREF="mask-array.html">mask_array</A></I></B>, and <B><I><A HREF="indirect-array.html">indirect_array</A></I></B>, represent and manipulate one-dimensional arrays of values. Elements in a <B><I>valarray</I></B> are indexed sequentially beginning with zero. </P>
<P>Unlike other classes in the Standard Library, <B><I>valarray</I></B> can only be used with a fairly narrow range of types. This restriction ensures that numeric operations on a <B><I>valarray</I></B> can be as efficient as possible by avoiding aliasing ambiguities and excess temporaries.</P>
<A NAME="sec5"><H3>Interface</H3></A>

<UL><PRE>namespace std {

  template &lt;class T&gt; class valarray {
  
  public:

  // types
  typedef T value_type;

  // constructors
  valarray( );
  explicit valarray(size_t);
  valarray(const T&amp;, size_t);
  valarray(const T* , size_t);
  valarray(const valarray&lt;T&gt;&amp;);
  valarray(const slice_array&lt;T&gt;&amp;);
  valarray(const gslice_array&lt;T&gt;&amp;);
  valarray(const mask_array&lt;T&gt;&amp;);
  valarray(const indirect_array&lt;T&gt;&amp;);

  // destructor
  ~valarray();

  // operator =
  valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator=(const slice_array&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator=(const gslice_array&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator=(const mask_array&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator=(const indirect_array&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator=(const T&amp;);

  // operator[]
  T operator[](size_t) const;
  T&amp; operator[](size_t);
  valarray&lt;T&gt; operator[](slice) const;
  slice_array&lt;T&gt; operator[](slice);
  valarray&lt;T&gt; operator[](const gslice&amp;) const;
  gslice_array&lt;T&gt; operator[](const gslice&amp;);
  valarray&lt;T&gt; operator[](const valarray&lt;bool&gt;&amp;) const;
  mask_array&lt;T&gt; operator[](const valarray&lt;bool&gt;&amp;);
  valarray&lt;T&gt; operator[](const valarray&lt;size_t&gt;&amp;) const;
  indirect_array&lt;T&gt; operator[](const valarray&lt;size_t&gt;&amp;);

  // unary operators
  valarray&lt;T&gt; operator+() const;
  valarray&lt;T&gt; operator-() const;
  valarray&lt;T&gt; operator~() const;
  valarray&lt;bool&gt; operator!() const;

  // computed assignment
  valarray&lt;T&gt;&amp; operator*=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator/=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator+=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator-=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator%=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator^=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator&amp;=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator|=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator&lt;&lt;=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator&gt;&gt;=(const valarray&lt;T&gt;&amp;);
  valarray&lt;T&gt;&amp; operator*=(const T&amp;);
  valarray&lt;T&gt;&amp; operator/=(const T&amp;);
  valarray&lt;T&gt;&amp; operator%=(const T&amp;);
  valarray&lt;T&gt;&amp; operator+=(const T&amp;);
  valarray&lt;T&gt;&amp; operator-=(const T&amp;);
  valarray&lt;T&gt;&amp; operator^=(const T&amp;);
  valarray&lt;T&gt;&amp; operator&amp;=(const T&amp;);
  valarray&lt;T&gt;&amp; operator|=(const T&amp;);
  valarray&lt;T&gt;&amp; operator&lt;&lt;=(const T&amp;);
  valarray&lt;T&gt;&amp; operator&gt;&gt;=(const T&amp;);


  // others
  size_t size() const;
  T sum() const;
  T min() const;
  T max() const;

  valarray&lt;T&gt; shift(int) const;
  valarray&lt;T&gt; cshift(int) const;

  valarray&lt;T&gt; apply(T func(T)) const;
  valarray&lt;T&gt; apply(T func(const T&amp;)) const;
  void resize(size_t, const T&amp; = T() );
  };

  // Nonmember binary operators
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator*(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator/(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator%(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator+(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator-(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator^(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator&amp;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator|(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator&lt;&lt;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator&gt;&gt;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&amp;&amp;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; 
  operator*(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator/(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator%(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator+(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator-(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator^(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator&amp;(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator|(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator&lt;&lt;(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator&gt;&gt;(const valarray&lt;T&gt;&amp;, const T&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&amp;&amp;(const valarray&lt;T&gt;&amp;, const T&amp;);

  template&lt;class T&gt; valarray&lt;T&gt; 
  operator*(const T&amp; , const valarray&lt;T&gt;&amp; ); 
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator/(const T&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator%(const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator+(const T&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator-(const T&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator^(const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator&amp;(const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator|(const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator&lt;&lt;(const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;T&gt; 
  operator&gt;&gt;(const T&amp;, const valarray&lt;T&gt;&amp;);
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&amp;&amp;(const T&amp;, const valarray&lt;T&gt;&amp;);

  // Nonmember logical operators

  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator==(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator!=(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&lt;(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&gt;(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&lt;=(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp; ); 
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&gt;=(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator||(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp;);

  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator==(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator!=(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&lt;(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&gt;(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&lt;=(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&gt;=(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator||(const valarray&lt;T&gt;&amp; , const T&amp; );
 
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator==(const T&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator!=(const T&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&lt;(const T&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&gt;(const T&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&lt;=(const T&amp; , const valarray&lt;T&gt;&amp; ); 
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator&gt;=(const T&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;bool&gt; 
  operator||(const T&amp; , const valarray&lt;T&gt;&amp; );

  // Nonmember transcendental functions

  template&lt;class T&gt; valarray&lt;T&gt; abs(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; acos(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; asin(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; atan(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; cos(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; cosh(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; exp(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; log(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; log10(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; sinh(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; sin(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; sqrt(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; tan(const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; tanh(const valarray&lt;T&gt;&amp; );

  template&lt;class T&gt; valarray&lt;T&gt; 
  atan2(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  atan2(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  atan2(const T&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  pow(const valarray&lt;T&gt;&amp; , const valarray&lt;T&gt;&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  pow(const valarray&lt;T&gt;&amp; , const T&amp; );
  template&lt;class T&gt; valarray&lt;T&gt; 
  pow(const T&amp; , const valarray&lt;T&gt;&amp; );
}
</PRE></UL>
<A NAME="sec6"><H3>Constructors</H3></A>

<A NAME="idx1254"></A><PRE><B>valarray</B>();</PRE>
<UL>
<P>Creates a <B><I>valarray</I></B> of length zero.</P>
</UL>


<A NAME="idx1255"></A><PRE>explicit <B>valarray</B>(size_t n);</PRE>
<UL>
<P>Creates a <B><I>valarray</I></B> of length <SAMP>n</SAMP>, containing <SAMP>n</SAMP> values initialized with the default value for type <SAMP>T</SAMP>. <SAMP>T</SAMP> must have a default constructor. </P>
</UL>


<A NAME="idx1256"></A><PRE><B>valarray</B>(const T&amp; value, size_t n);</PRE>
<UL>
<P>Creates a <B><I>valarray</I></B> of length <SAMP>n</SAMP>, containing <SAMP>n</SAMP> values initialized with <SAMP>value</SAMP>. </P>
</UL>


<A NAME="idx1257"></A><PRE><B>valarray</B>(const T* value, size_t n);</PRE>
<UL>
<P>Creates a <B><I>valarray</I></B> of length <SAMP>n</SAMP>, containing <SAMP>n</SAMP> values initialized with the first <SAMP>n</SAMP> elements pointed to by <SAMP>value</SAMP>. The array pointed to by <SAMP>value</SAMP> must contain at least <SAMP>n</SAMP> values.</P>
</UL>


<A NAME="idx1258"></A><PRE><B>valarray</B>(const valarray&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Creates a copy of <SAMP>x</SAMP>.</P>
</UL>


<A NAME="idx1259"></A><PRE><B>valarray</B>(const slice_array&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Creates a <B><I>valarray</I></B> from the <B><I><A HREF="slice-array.html">slice_array</A></I></B> <SAMP>x</SAMP>. </P>
</UL>


<A NAME="idx1260"></A><PRE><B>valarray</B>(const gslice_array&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Creates a <B><I>valarray</I></B> from the <B><I><A HREF="gslice-array.html">gslice_array</A></I></B> <SAMP>x</SAMP>. </P>
</UL>


<A NAME="idx1261"></A><PRE><B>valarray</B>(const mask_array&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Creates a <B><I>valarray</I></B> from the <B><I><A HREF="mask-array.html">mask_array</A></I></B> <SAMP>x</SAMP>. </P>
</UL>


<A NAME="idx1262"></A><PRE><B>valarray</B>(const indirect_array&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Creates a <B><I>valarray</I></B> from the <B><I><A HREF="indirect-array.html">indirect_array</A></I></B> <SAMP>x</SAMP>. </P>
</UL>

<A NAME="sec7"><H3>Destructor</H3></A>

<A NAME="idx1263"></A><PRE><B>~valarray</B>();</PRE>
<UL>
<P>Applies <SAMP>~T()</SAMP> to every element in the <B><I>valarray</I></B> and returns all allocated memory. </P>
</UL>

<A NAME="sec8"><H3>Assignment Operators</H3></A>
<BLOCKQUOTE><HR><B>
NOTE -- Before calling these functions, portable code should guarantee that both sides of the assignment operator refer to objects of the same size.
</B><HR></BLOCKQUOTE>

<A NAME="idx1264"></A><PRE>valarray&lt;T&gt;&amp; 
<B>operator=</B>(const valarray&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Assigns to each element of self the corresponding value from <SAMP>x</SAMP>. If self has more or fewer elements than <SAMP>x</SAMP>, then the resulting behavior is undefined.</P>
<P>self is resized to match the size of <SAMP>x</SAMP>. Returns a reference to self.</P>
</UL>


<A NAME="idx1265"></A><PRE>valarray&lt;T&gt;&amp; 
<B>operator=</B>(const T&amp; x);</PRE>
<UL>
<P>Assigns to each element of self the value of <SAMP>x</SAMP>. Returns a reference to self.</P>
</UL>


<A NAME="idx1266"></A><PRE>valarray&lt;T&gt;&amp; 
<B>operator=</B>(const slice_array&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Copies elements from <SAMP>x</SAMP> into self by stepping through each slice consecutively. If self has more or fewer elements than <SAMP>x</SAMP>, then self is resized to match the size of <SAMP>x</SAMP>. Returns a reference to self.</P>
</UL>


<A NAME="idx1267"></A><PRE>valarray&lt;T&gt;&amp; 
<B>operator=</B>(const gslice_array&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Copies elements from <SAMP>x</SAMP> into self by stepping through each slice consecutively. If self has more or fewer elements than <SAMP>x</SAMP>, then self is resized to match the size of <SAMP>x</SAMP>. Returns a reference to self.</P>
</UL>


<A NAME="idx1268"></A><PRE>valarray&lt;T&gt;&amp; 
<B>operator=</B>(const mask&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Copies each consecutive element from <SAMP>x</SAMP> into self. If self has more or fewer elements than <SAMP>x</SAMP>, then self is resized to match the size of <SAMP>x</SAMP>. Returns a reference to self.</P>
</UL>


<A NAME="idx1269"></A><PRE>valarray&lt;T&gt;&amp; 
<B>operator=</B>(const indirect_array&lt;T&gt;&amp; x);</PRE>
<UL>
<P>Copies each consecutive element from <SAMP>x</SAMP> into self. If self has more or fewer elements than <SAMP>x</SAMP>, then self is resized to match the size of <SAMP>x</SAMP>. Returns a reference to self.</P>
</UL>

<A NAME="sec9"><H3>Element Access Operators</H3></A>

<A NAME="idx1270"></A><PRE>T&amp; <B>operator[]</B>(size_type n);</PRE>
<UL>
<P>Returns a reference to element <SAMP>n</SAMP> of self. The result can be used as an <SAMP>lvalue</SAMP>. This reference is valid until the resize function is called or the array is destroyed. The index <SAMP>n</SAMP> must be between <SAMP>0</SAMP> and <SAMP>size</SAMP> less one.</P>
</UL>


<A NAME="idx1271"></A><PRE>T <B>operator[]</B>(size_type n) const;</PRE>
<UL>
<P>Returns the value at element <SAMP>n</SAMP> of self. The index <SAMP>n</SAMP> must be between <SAMP>0</SAMP> and <SAMP>size</SAMP> less one.</P>
</UL>

<A NAME="sec10"><H3>Subset Operators</H3></A>

<A NAME="idx1272"></A><PRE>valarray&lt;T&gt; <B>operator[]</B>(slice s) const;</PRE>
<UL>
<P>Returns a subset of the self as specified by <SAMP>s</SAMP>. The return value is a new <B><I>valarray</I></B> object. See <B><I><A HREF="slice.html">slice</A></I></B> for a description of a BLAS-like slice.</P>
</UL>


<A NAME="idx1273"></A><PRE>slice_array&lt;T&gt; <B>operator[]</B>(slice s); </PRE>
<UL>
<P>Returns a subset of the self as specified by <SAMP>s</SAMP>. The return value is a <B><I><A HREF="slice-array.html">slice_array</A></I></B> referencing elements inside self. See <B><I><A HREF="slice.html">slice</A></I></B> and <B><I>slice_array</I></B>.</P>
</UL>


<A NAME="idx1274"></A><PRE>valarray&lt;T&gt; <B>operator[]</B>(const gslice&amp; s) const;</PRE>
<UL>
<P>Returns a subset of the self as specified by <SAMP>s</SAMP>. The return value is a new <B><I>valarray</I></B> object. See <B><I><A HREF="gslice.html">gslice</A></I></B> for a description of a generalized slice.</P>
</UL>


<A NAME="idx1275"></A><PRE>gslice_array&lt;T&gt; <B>operator[]</B>(const gslice&amp; s); </PRE>
<UL>
<P>Returns a subset of the self as specified by <SAMP>s</SAMP>. The return value is a <B><I><A HREF="gslice-array.html">gslice_array</A></I></B> referencing elements inside self. See <B><I><A HREF="gslice.html">gslice</A></I></B> and <B><I>gslice_array</I></B>.</P>
</UL>


<A NAME="idx1276"></A><PRE>valarray&lt;T&gt; <B>operator[]</B>(const valarray&lt;bool&gt;&amp; v) const;</PRE>
<UL>
<P>Returns a subset of the self as specified by <SAMP>v</SAMP>. The return value is a new <B><I>valarray</I></B> object.</P>
</UL>


<A NAME="idx1277"></A><PRE>mask_array&lt;T&gt; <B>operator[]</B>(const valarray&lt;bool&gt;&amp; v);  </PRE>
<UL>
<P>Returns a subset of the self as specified by <SAMP>v</SAMP>. The return value is a <B><I><A HREF="mask-array.html">mask_array</A></I></B> referencing elements inside self. See <B><I>mask_array</I></B>.</P>
</UL>


<A NAME="idx1278"></A><PRE>valarray&lt;T&gt; <B>operator[]</B>(const valarray&lt;size_t&gt;&amp; v) const;</PRE>
<UL>
<P>Returns a subset of the self as specified by <SAMP>v</SAMP>. The return value is a new <B><I>valarray</I></B> object.</P>
</UL>


<A NAME="idx1279"></A><PRE>Indirect_array&lt;T&gt; <B>operator[]</B>(const valarray&lt;size_t&gt;&amp; v); </PRE>
<UL>
<P>Returns a subset of the self as specified by <SAMP>v</SAMP>. The return value is a <B><I><A HREF="indirect-array.html">indirect_array</A></I></B> referencing elements inside self. See <B><I>indirect_array</I></B>.</P>
</UL>

<A NAME="sec11"><H3>Unary Operators</H3></A>

<A NAME="idx1280"></A><PRE>valarray&lt;T&gt; <B>operator+</B>() const;</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the array in self where each element has been initialized by applying <SAMP>operator+()</SAMP> to the corresponding element in self.   This operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports an <SAMP>operator+()</SAMP> that returns <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>. </P>
</UL>


<A NAME="idx1281"></A><PRE>valarray&lt;T&gt; <B>operator-</B>() const;</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the array in self where each element has been initialized by applying <SAMP>operator-()</SAMP> to the corresponding element in self.   This operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports an <SAMP>operator-()</SAMP> returning <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>. </P>
</UL>


<A NAME="idx1282"></A><PRE>valarray&lt;T&gt; <B>operator~</B>() const;</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the array in self where each element has been initialized by applying <SAMP>operator~()</SAMP> to the corresponding element in self.   This operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports an <SAMP>operator~()</SAMP> returning <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>. </P>
</UL>


<A NAME="idx1283"></A><PRE>valarray&lt;bool&gt; <B>operator!</B>() const;</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the array in self where each element has been initialized by applying <SAMP>operator!()</SAMP> to the corresponding element in self.   This operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports an <SAMP>operator!()</SAMP>  returning <SAMP>bool</SAMP> or a type convertible to <SAMP>bool</SAMP>.</P>
</UL>

<A NAME="sec12"><H3>Computed Assignment Operators</H3></A>

<A NAME="idx1284"></A><PRE>valarray&lt;T&gt;&amp; <B>operator*=</B>(const valarray&lt;T&gt;&amp; val);
valarray&lt;T&gt;&amp; <B>operator/=</B>(const valarray&lt;T&gt;&amp; val);
valarray&lt;T&gt;&amp; <B>operator%=</B>(const valarray&lt;T&gt;&amp; val);
valarray&lt;T&gt;&amp; <B>operator+=</B>(const valarray&lt;T&gt;&amp; val);
valarray&lt;T&gt;&amp; <B>operator-=</B>(const valarray&lt;T&gt;&amp; val);
valarray&lt;T&gt;&amp; <B>operator^=</B>(const valarray&lt;T&gt;&amp; val);
valarray&lt;T&gt;&amp; <B>operator&amp;=</B>(const valarray&lt;T&gt;&amp; val);
valarray&lt;T&gt;&amp; <B>operator|=</B>(const valarray&lt;T&gt;&amp; val);
valarray&lt;T&gt;&amp; <B>operator&lt;&lt;=</B>(const valarray&lt;T&gt;&amp; val);
valarray&lt;T&gt;&amp; <B>operator&gt;&gt;=</B>(const valarray&lt;T&gt;&amp; val);</PRE>
<UL>
<P>Applies the indicated operation to each element in self, using the corresponding element from <SAMP>val</SAMP> as the right hand argument (for example, for all <SAMP>0 &lt;= n &lt; *this.size(), *this[n] += val[n]</SAMP>).   This operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports the indicated operation. The length of <SAMP>val</SAMP> must also equal the length of self. Returns self.</P>
</UL>


<A NAME="idx1285"></A><PRE>valarray&lt;T&gt;&amp; <B>operator*=</B>(const T&amp; val);
valarray&lt;T&gt;&amp; <B>operator/=</B>(const T&amp; val);
valarray&lt;T&gt;&amp; <B>operator%=</B>(const T&amp; val);
valarray&lt;T&gt;&amp; <B>operator+=</B>(const T&amp; val);
valarray&lt;T&gt;&amp; <B>operator-=</B>(const T&amp; val);
valarray&lt;T&gt;&amp; <B>operator^=</B>(const T&amp; val);
valarray&lt;T&gt;&amp; <B>operator&amp;=</B>(const T&amp; val);
valarray&lt;T&gt;&amp; <B>operator|=</B>(const T&amp; val);
valarray&lt;T&gt;&amp; <B>operator&lt;&lt;=</B>(const T&amp; val);
valarray&lt;T&gt;&amp; <B>operator&gt;&gt;=</B>(const T&amp; val);</PRE>
<UL>
<P>Applies the indicated operation to each element in self, using <SAMP>val</SAMP> as the right hand argument (for example, for all <SAMP>0 &lt;= n &lt; *this.size(), *this[n] += val</SAMP>).   This operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports the indicated operation. Returns self.</P>
</UL>

<A NAME="sec13"><H3>Member Functions</H3></A>

<A NAME="idx1286"></A><PRE>size_t <B>size</B>() const;</PRE>
<UL>
<P>Returns the number of elements.</P>
</UL>


<A NAME="idx1287"></A><PRE>T <B>sum</B>() const;</PRE>
<UL>
<P>This function uses <SAMP>operator+=</SAMP> to sum all the elements of the array. Sum can only be called for a <B><I>valarray</I></B> instantiated on a type that supports <SAMP>operator+=()</SAMP>. The array must also have at least one element.    Returns the sum of all elements in the array.</P>
</UL>


<A NAME="idx1288"></A><PRE>T <B>min</B>() const;</PRE>
<UL>
<P>This function uses <SAMP>operator&lt;()</SAMP> to find the minimum element in the array. The array must have at least one element. Returns the minimum of all elements in the array.</P>
</UL>


<A NAME="idx1289"></A><PRE>T <B>max</B>() const;</PRE>
<UL>
<P>This function uses <SAMP>operator&lt;()</SAMP> to find the maximum element in the array. The array must have at least one element. Returns the maximum of all elements in the array.</P>
</UL>


<A NAME="idx1290"></A><PRE>valarray&lt;T&gt; <B>shift</B>(int n) const;</PRE>
<UL>
<P>This function returns a new <B><I>valarray</I></B> object whose elements have all been shifted <SAMP>n</SAMP> places to left or right with respect to self. A positive value of <SAMP>n</SAMP> shifts the elements to the left, a negative value to the right. The default constructor for <SAMP>T</SAMP> is used to fill in behind the shifting elements. For example, applying <SAMP>shift(2)</SAMP> to an array corresponding to [3,4,5,6] results in [5,6,0,0], and applying <SAMP>shift(-1)</SAMP> to [3,4,5,6] results in [0,3,4,5].</P>
</UL>


<A NAME="idx1291"></A><PRE>valarray&lt;T&gt; <B>cshift</B>(int n) const;</PRE>
<UL>
<P>This function returns a new <B><I>valarray</I></B> object whose elements have all been rotated <SAMP>n</SAMP> places to left or right with respect to self. A positive value of <SAMP>n</SAMP> shifts the elements to the left, a negative value to the right. For example, applying <SAMP>shift(2)</SAMP> to an array corresponding to [3,4,5,6] results in [5,6,3,4], and applying <SAMP>shift(-1)</SAMP> to [3,4,5,6] results in [6,3,4,5].</P>
</UL>


<A NAME="idx1292"></A><PRE>valarray&lt;T&gt; <B>apply</B>(T func(T)) const;</PRE>
<UL>
<P>This function returns a new <B><I>valarray</I></B> object with the same length as the array in self but whose elements have all been initialized by applying the argument function <SAMP>func</SAMP> to the corresponding element in self (in other words, for all<SAMP> n &lt; *this.size()</SAMP>, the <SAMP>nth</SAMP> element of the returned array equals<SAMP> func(*this[n]))</SAMP>.</P>
</UL>


<A NAME="idx1293"></A><PRE>valarray&lt;T&gt; <B>apply</B>(T func(const T&amp;)) const;</PRE>
<UL>
<P>This function returns a new <B><I>valarray</I></B> object with the same length as the array in self but whose elements have all been initialized by applying the argument function <SAMP>func</SAMP> to the corresponding element in self (in other words, for all <SAMP>0 &lt;=  n &lt; *this.size()</SAMP>, the <SAMP>nth</SAMP> element of the returned array equals <SAMP>func(*this[n]))</SAMP>.</P>
</UL>


<A NAME="idx1294"></A><PRE>void 
<B>resize</B>(size_type sz, T c = T());</PRE>
<UL>
<P>Changes the length of self to <SAMP>sz</SAMP>, and assigns <SAMP>c</SAMP> to every element. This function also invalidates all outstanding references to self. </P>
</UL>

<A NAME="sec14"><H3>Nonmember Binary Operators</H3></A>

<A NAME="idx1295"></A><PRE>template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator*</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator/</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator%</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator+</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator-</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator^</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator&amp;</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator|</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator&lt;&lt;</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator&gt;&gt;</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the argument arrays where each element has been initialized by applying the indicated operation to the corresponding elements in the argument arrays.   The operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports a form of the indicated operation that returns <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>. The argument arrays must have the same length.</P>
</UL>


<A NAME="idx1296"></A><PRE>template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator*</B>(const valarray&lt;T&gt;&amp; lhs, T&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator/</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator%</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator+</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator-</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator^</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator&amp;</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator|</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator&lt;&lt;</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator&gt;&gt;</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the <B><I>valarray</I></B> <SAMP>lhs</SAMP> where each element has been initialized by applying the indicated operation to the corresponding element in <SAMP>lhs</SAMP> and the value <SAMP>rhs</SAMP>.   The operation can only be used with a type <SAMP>T</SAMP> that supports a form of the indicated operation that returns <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>. </P>
</UL>


<A NAME="idx1297"></A><PRE>template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator*</B>(const T&amp; rhs, valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator/</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator%</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator+</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator-</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator^</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator&amp;</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator|</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator&lt;&lt;</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>operator&gt;&gt;</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the <B><I>valarray</I></B> <SAMP>rhs</SAMP> where each element has been initialized by applying the indicated operation to the corresponding element in <SAMP>rhs</SAMP> and the value <SAMP>lhs</SAMP>. The operation can only be used with a type <SAMP>T</SAMP> that supports a form of the indicated operation that returns <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>. </P>
</UL>

<A NAME="sec15"><H3>Nonmember Logical Operators</H3></A>

<A NAME="idx1298"></A><PRE>template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator==</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator!=</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&lt;</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&gt;</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&lt;=</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&gt;=</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&amp;&amp;</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator||</B>(const valarray&lt;T&gt;&amp; lhs, const valarray&lt;T&gt;&amp; rhs);</PRE>
<UL>
<P>Returns a <B><I>valarray&lt;bool&gt;</I></B> object of the same size as the argument arrays where each element has been initialized by applying the indicated operation to the corresponding elements in the argument arrays. The operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that support a form of the indicated operation that returns <SAMP>bool</SAMP> or a type convertible to&nbsp;<SAMP>bool</SAMP>. The argument arrays must have the same length.</P>
</UL>


<A NAME="idx1299"></A><PRE>template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator==</B>(const valarray&lt;T&gt;&amp; lhs, T&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator!=</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&lt;</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&gt;</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&lt;=</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&gt;=</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&amp;&amp;</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator||</B>(const valarray&lt;T&gt;&amp; lhs, const T&amp; rhs);</PRE>
<UL>
<P>Returns a <B><I>valarray&lt;bool&gt;</I></B> object of the same size as the <B><I>valarray</I></B> <SAMP>lhs</SAMP> where each element has been initialized by applying the indicated operation to the corresponding element in <SAMP>lhs</SAMP> and the value <SAMP>rhs</SAMP>.   The operation can only be used with a type <SAMP>T</SAMP> that supports a form of the indicated operation that returns <SAMP>bool</SAMP> or a type convertible to <SAMP>bool</SAMP>. </P>
</UL>


<A NAME="idx1300"></A><PRE>template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator==</B>(const T&amp; rhs, valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator!=</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&lt;</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&gt;</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&lt;=</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&gt;=</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator&amp;&amp;</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);
template &lt;class T&gt; valarray&lt;bool&gt; 
<B>operator||</B>(const T&amp; lhs, const valarray&lt;T&gt;&amp; rhs);</PRE>
<UL>
<P>Returns a <B><I>valarray&lt;bool&gt;</I></B> object of the same size as the valarray <SAMP>rhs</SAMP> where each element has been initialized by applying indicated operation to the corresponding element in <SAMP>rhs</SAMP> and the value <SAMP>lhs</SAMP>.   The operation can only be used with a type <SAMP>T</SAMP> that supports a form of the indicated operation that returns <SAMP>bool</SAMP> or a type convertible to <SAMP>bool</SAMP>. </P>
</UL>

<A NAME="sec16"><H3>Nonmember Transcen-dental Functions</H3></A>

<A NAME="idx1301"></A><PRE>template &lt;class T&gt; valarray&lt;T&gt; <B>abs</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>acos</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>asin</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>atan</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>cos</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>cosh</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>exp</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>log</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>log10</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>sin</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>sinh</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>sqrt</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>tan</B>(const valarray&lt;T&gt;&amp; v);
template &lt;class T&gt; valarray&lt;T&gt; <B>tanh</B>(const valarray&lt;T&gt;&amp; v);</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the argument array where each element has been initialized by applying the indicated transcendental function to the corresponding elements in the argument array.   The operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports a unique form of the indicated function that returns <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>. </P>
</UL>


<A NAME="idx1302"></A><PRE>template &lt;class T&gt; valarray&lt;T&gt; 
<B>atan2</B>(const valarray&lt;T&gt;&amp; v, const valarray&lt;T&gt;&amp; v2);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>pow</B>(const valarray&lt;T&gt;&amp; v, const valarray&lt;T&gt;&amp; v2);</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the argument arrays where each element has been initialized by applying the indicated transcendental function to the corresponding elements in the argument arrays.   The operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports a unique form of the indicated function that returns <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>. </P>
</UL>


<A NAME="idx1303"></A><PRE>template &lt;class T&gt; valarray&lt;T&gt; 
<B>atan2</B>(const valarray&lt;T&gt;&amp; v, const T&amp; v2);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>pow</B>(const valarray&lt;T&gt;&amp; v, const T&amp; v2);</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the argument array <SAMP>v</SAMP> where each element has been initialized by applying the indicated transcendental function to the corresponding elements in <SAMP>v</SAMP> along with the value <SAMP>v2</SAMP>.   The operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports a unique form of the indicated function that returns <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>. </P>
</UL>


<A NAME="idx1304"></A><PRE>template &lt;class T&gt; valarray&lt;T&gt; 
<B>atan2</B>(const T&amp; v, const valarray&lt;T&gt; v2);
template &lt;class T&gt; valarray&lt;T&gt; 
<B>pow</B>(const T&amp; v, const valarray&lt;T&gt; v2);</PRE>
<UL>
<P>Returns a new <B><I>valarray</I></B> object of the same size as the argument array <SAMP>v2</SAMP> where each element has been initialized by applying the indicated transcendental function to the corresponding elements in <SAMP>v2</SAMP> along with the value <SAMP>v</SAMP>.   The operation can only be applied to a <B><I>valarray</I></B> instantiated on a type <SAMP>T</SAMP> that supports a unique form of the indicated function that returns <SAMP>T</SAMP> or a type convertible to <SAMP>T</SAMP>.</P>
</UL>

<A NAME="sec17"><H3>Example</H3></A>

<UL><PRE>//
//  valarray.cpp
//

#include &lt;cstddef&gt;      // for size_t
#include &lt;iostream&gt;     // for cout
#include &lt;valarray&gt;     // for valarray


template &lt;class T&gt; 
inline std::ostream&
operator&lt;&lt; (std::ostream &amp;out, const std::valarray&lt;T&gt; &amp;v)
{
    out &lt;&lt; '[';

    for (std::size_t i = 0; i &lt; v.size (); ++i) {
        out &lt;&lt; v [i];
        if (i &lt; v.size () - 1)
            out &lt;&lt; ',';
    }

    return out &lt;&lt; ']';
}


int main ()
{
    const int ibuf[]  = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };  
    const int ibuf2[] = { 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 };  

    // create 2 valarrays of ints
    std::valarray&lt;int&gt; vi (ibuf, sizeof ibuf / sizeof *ibuf);
    std::valarray&lt;int&gt; vi2 (ibuf2, sizeof ibuf2 / sizeof *ibuf2);

    // print them out
    std::cout &lt;&lt; vi &lt;&lt; '\n' &lt;&lt; vi2 &lt;&lt; '\n';

    vi += vi2;
    vi2 *= 2;

    std::valarray&lt;int&gt; vi3 = vi2 % vi;

    // print them out again
    std::cout &lt;&lt; vi &lt;&lt; '\n' &lt;&lt; vi2 &lt;&lt; '\n' &lt;&lt; vi3 &lt;< '\n';

    return 0;
}


Program Output:
</PRE></UL>
<UL><PRE>[0,1,2,3,4,5,6,7,8,9]
[10,11,12,13,14,15,16,17,18,19]
[10,12,14,16,18,20,22,24,26,28]
[20,22,24,26,28,30,32,34,36,38]
[0,10,10,10,10,10,10,10,10,10]
</PRE></UL>
<A NAME="sec18"><H3>See Also</H3></A>
<P><B><I><A HREF="slice.html">slice</A></I></B>, <B><I><A HREF="gslice.html">gslice</A></I></B>, <B><I><A HREF="gslice-array.html">gslice_array</A></I></B>, <B><I><A HREF="mask-array.html">mask_array</A></I></B>, <B><I><A HREF="indirect-array.html">indirect_array</A></I></B></P>
<A NAME="sec19"><H3>Standards Conformance</H3></A>
<P><I>ISO/IEC 14882:1998 -- International Standard for Information Systems --Programming Language C++, Section 26.3.2</I></P>

<BR>
<HR>
<A HREF="valarray-h.html"><IMG SRC="images/bprev.gif" WIDTH=20 HEIGHT=21 ALT="Previous file" BORDER=O></A><A HREF="noframes.html"><IMG SRC="images/btop.gif" WIDTH=56 HEIGHT=21 ALT="Top of Document" BORDER=O></A><A HREF="booktoc.html"><IMG SRC="images/btoc.gif" WIDTH=56 HEIGHT=21 ALT="Contents" BORDER=O></A><A HREF="tindex.html"><IMG SRC="images/bindex.gif" WIDTH=56 HEIGHT=21 ALT="Index page" BORDER=O></A><A HREF="vector-h.html"><IMG SRC="images/bnext.gif" WIDTH=20 HEIGHT=21 ALT="Next file" BORDER=O></A>

<!-- Google Analytics tracking code -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
    _uacct = "UA-1775151-1";
    urchinTracker();
</script>
<!-- end of Google Analytics tracking code -->

</BODY>
</HTML>
