/*
	Copyright (C) 2011 Mihai Vasilian

	This program is free software; you can redistribute it and/or modify it under the terms of the GNU General
	Public License as published by the Free Software Foundation; either version 2 of the License, or (at your
	option) any later version.

	This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
	implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
	for more details.

	You should have received a copy of the GNU General Public License along with this program. 
	If not, see http://www.gnu.org/licenses/.

	contact: grayasm@gmail.com
*/


#include "Lexer.hpp"






namespace lex
{


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	Lexer* Lexer::m_inst = NULL;

	Lexer::Lexer()
	{
		m_start=NULL;
		m_term=NULL;
	};

	Lexer::~Lexer()
	{
	};


	Lexer& Lexer::Inst()
	{
		if(m_inst==NULL) m_inst = new Lexer();
		return *m_inst;
	};

	void Lexer::Destroy()
	{
		if(m_inst) delete m_inst;
		m_inst = 0;
	};

	void Lexer::Initialize(const Base::Ptr& start, const Base::Ptr& term, const lex::IniParams& iniparams)
	{
		m_start = start;
		m_term = term;
		m_iniparams = iniparams;
	};

	void Lexer::CheckFile(lex::InputFile& in, lex::Base::Syntax& syntax, Reports& reps)
	{
		//initialize file position
		size_t pos = in.tellg();

		unsigned int c=0;
		if(!in.eof()) 
			in >> c;

		while(!in.eof())
		{
			lex::Base::Productions prods;
			prods.push_back(lex::Base::Production());

			lex::Report rep;
			
			bool res = CheckStart(in, c, prods, rep);

			
			//Optional,Repeat,Negation: return true without advancing the stream position.
			//Negation: returns true without valid production->Recover

			if( !res || (*prods.begin()).empty() )
			{
				Recover(in, c, m_term);
				
				//when m_term (e.g. ";") cannot be parsed by lexer, stream may enter infinite loop.
				if(pos - 1 == in.tellg())
				{
					throw misc::exception("Incorrect grammar: lexer does not parse term token.");
					//please correct the grammar
				}


				//Valid reps only
				if( !rep.GetErrorList().empty() )
					reps.push_back(rep);
				
			}			
			else
			{			
				/*
				In computer science, a context-free grammar is said to be an ambiguous grammar if there exists a string 
				that can be generated by the grammar in more than one way (i.e., the string admits more than one parse tree or, 
				equivalently, more than one leftmost derivation). 
				A context-free language is inherently ambiguous if all context-free grammars generating that language are ambiguous.
				Some programming languages have ambiguous grammars; in this case, semantic information is needed to select 
				the intended parse tree of an ambiguous construct.
				*/
				SolveAmbiguity(prods);


				AddProduction(syntax, prods);
			}

			if(!in.eof())
				in >> c;
						
			//store current position
			pos = in.tellg();

			LF_DUMP("Lexer::CheckFile", res, c, in, false, lex::Error(), lex::Token(), *prods.begin());
		}//while.eof	
	};


	bool Lexer::CheckStart( lex::InputFile& in, unsigned int c, lex::Base::Productions& prods, lex::Report& rep )
	{
		bool res = false;
		try
		{			
			lex::Token tokgen;
			res = m_start->check(in, c, prods, tokgen, rep);
			
			LF_DUMP("Lexer::CheckStart", res, c, in, false, lex::Error(), tokgen, *prods.begin());
		}
		catch(const misc::exception& exc)
		{
			misc::cout << exc.what() << std::endl;			
		}
		catch(...)
		{			
			misc::cout << "Unknown exception" << std::endl;
		}

		return res;
	};


	bool Lexer::CheckTree( lex::InputFile& in, unsigned int c, Tree& tree, lex::Base::Productions& prods, lex::Token& token, lex::Report& rep )
	{
		if(tree.empty()) return false;		

		//must preserve correct position
		/*
			stream: "1autoe"
			m["syntax"] = 
				(m["0_9"] && m["auto"] && m["0_9"]) ||
				(m["0_9"] && m["auto"] && m["a_z"]) ;

			2-nd rule begin to parse in wrong position 5 instead of 1.
		*/
		size_t pos = in.tellg();

		if(pos <= 0)
		{
			int brk=0; brk;
		}


		size_t row = in.row();
		size_t col = in.col();
		
		Tree::child_iterator cib = tree.child_begin();
		Tree::child_iterator cie = tree.child_end();
		while(cib != cie)
		{
			It it = tree.get_iterator(cib);
			Fbit fbbeg = tree.first_branch_begin(it);
			Fbit fbend = tree.first_branch_end(it);
			if(CheckBranches(in, c, tree, fbbeg, fbend, prods, token, rep))
			{			
				
				LF_DUMP("Lexer::CheckTree {CB:true}", true, c, in, false, lex::Error(), token, *prods.begin());

				//in = inf;
				return true;
			}

			cib++;
		}//while

		//restore initial position
		in.seekg(pos, row, col);

		LF_DUMP("Lexer::CheckTree {CB}end", false, c, in, false, lex::Error(), token, *prods.begin());

		
		return false;
	};


	
	bool Lexer::CheckBranches( lex::InputFile& in, unsigned int c, Tree& tree, Fbit beg, Fbit end, lex::Base::Productions& prods, lex::Token& token, lex::Report& rep )
	{		

		size_t pos = in.tellg();
		size_t row = in.row();
		size_t col = in.col();

		Base::Ptr rule = *beg;

		unsigned int tc = c;
		
		if(rule->check(in, c, prods, token, rep))
		{
			Fbit temp = beg;
			++temp;

			if(temp == end)
			{
				LF_DUMP("Lexer::CheckBranches[temp==end]", true, c, in, false, lex::Error(), token, *prods.begin());

				//reduce
				return true;
			}


			if( !in.eos() )
				in >> tc;


			if(tc == 0x4)
			{
				//tested! ; throw misc::exception("not tested");
				//return false;				
			}

			if( in.eos() )
			{				
				tc = (char) 0x4;//end of transmit
				//return false;
			}
				
			

			//the reason behind this 0x4 is that we should not return false unless nothing is to be done.
			//m["vocale"] = m["vocala"] & 0 * m["vocala"];   the right of & now will return true for in.eof() and c=0x4
			
			if( CheckBranches(in, tc, tree, temp, end, prods, token, rep) )
			{
				/*
				text: 'a_'
				m["syntax"] = (m["a"] & 0 * m["_"]) + m["a"];

				When left side of + needs to re-validate the stream resized to 1 position, it consumes
				first token 'a' and then reaches the end of stream (which in reality is '_'). 
				That's why I put back the eof, and it must be removed at the top level of Lexer.
				*/

				if(tc == 0x4) 
				{					
					//prevent infinite loop within complex rules, it remains in loop 
					//parsing last token retrieved from file, and keeping file position on eof
					if( !in.eof() )
					{
						in << 1;
					}
					
					
					//throw misc::exception("to be tested again");
				}				

				LF_DUMP("Lexer::CheckBranches[true {CB:true}]", true, c, in, false, lex::Error(), token, *prods.begin());
				return true;
			}
			else
			{								
				//restore initial position
				in.seekg(pos, row, col);

				LF_DUMP("Lexer::CheckBranches[true {CB:false}]", false, c, in, false, lex::Error(), token, *prods.begin());				
				return false;
			}//else
		}	


		
		//check siblings branches
		{
			It it = tree.get_iterator(beg);
			Tree::node& nod = *it;
			++it;			
			while(it != nod.m_owner->m_list.end())
			{
				Fbit beg2 = tree.first_branch_begin(it);
				Fbit end2 = tree.first_branch_end(it);

				if(CheckBranches(in, c, tree, beg2, end2, prods, token, rep)) 
				{				
					LF_DUMP("Lexer::CheckBranches[false {CB:true}]", true, c, in, false, lex::Error(), token, *prods.begin());

					//in = inf3;
					return true;
				}

				++it;
			}
		}

		//restore initial position
		in.seekg(pos, row, col);

		
		LF_DUMP("Lexer::CheckBranches[false {CB}end]", false, c, in, false, lex::Error(), token, *prods.begin());
		return false;	
	};//parse

	

	void Lexer::Recover( lex::InputFile& in, unsigned int& c, Base::Ptr term )
	{	
		lex::Base::Productions prods;
		prods.push_back(lex::Base::Production());
		lex::Token token;
		lex::Report rep;

		while(!in.eof() && !term->check(in, c, prods, token, rep))
			in >> c;

		LF_DUMP("Lexer::Recover", true, c, in, false, lex::Error(), token, *prods.begin());
	};

	void Lexer::SolveAmbiguity(lex::Base::Productions& /*prods*/)
	{

	};

	void Lexer::AddProduction(lex::Base::Syntax& syntax, const lex::Base::Productions& prods)
	{
		/*
		misc::string skipchr(" \t\n");
		lex::Base::Production goodprod;
		for(lex::Base::Production::const_iterator beg = prod.begin(); beg != prod.end(); ++beg)
		{
			if((*beg).find_first_not_of(skipchr) != misc::string::npos)
			{
				goodprod.push_back(*beg);
			}
		}//for

		if(goodprod.empty()) 
		*/
		if(prods.empty())
		{
			throw misc::exception("empty production");
		}

		
		/*if(goodprod.size() < 3 || (*++goodprod.begin()) != "=")
		{
			throw misc::exception("incorrect assignment in production");
		}*/

		//syntax.push_back(goodprod);
		syntax.push_back(*prods.begin());
	};


};//namespace lex


